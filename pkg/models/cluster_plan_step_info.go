// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterPlanStepInfo Information about a step in a plan.
//
// swagger:model ClusterPlanStepInfo
type ClusterPlanStepInfo struct {

	// When the step completed (ISO format in UTC)
	// Format: date-time
	Completed strfmt.DateTime `json:"completed,omitempty"`

	// The duration of the step in MS
	DurationInMillis int64 `json:"duration_in_millis,omitempty"`

	// Human readable summaries of the step, including messages for each stage of the step
	// Required: true
	InfoLog []*ClusterPlanStepLogMessageInfo `json:"info_log"`

	// Current stage that the step is in
	// Required: true
	// Enum: [starting completed in_progress]
	Stage *string `json:"stage"`

	// When the step started (ISO format in UTC)
	// Required: true
	// Format: date-time
	Started *strfmt.DateTime `json:"started"`

	// The status of the step (success, warning, error - warning means something didn't go as expected but it was not serious enough to abort the plan)
	// Required: true
	// Enum: [success warning error pending]
	Status *string `json:"status"`

	// ID of current step
	// Required: true
	StepID *string `json:"step_id"`
}

// Validate validates this cluster plan step info
func (m *ClusterPlanStepInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfoLog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStarted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStepID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPlanStepInfo) validateCompleted(formats strfmt.Registry) error {
	if swag.IsZero(m.Completed) { // not required
		return nil
	}

	if err := validate.FormatOf("completed", "body", "date-time", m.Completed.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPlanStepInfo) validateInfoLog(formats strfmt.Registry) error {

	if err := validate.Required("info_log", "body", m.InfoLog); err != nil {
		return err
	}

	for i := 0; i < len(m.InfoLog); i++ {
		if swag.IsZero(m.InfoLog[i]) { // not required
			continue
		}

		if m.InfoLog[i] != nil {
			if err := m.InfoLog[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("info_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var clusterPlanStepInfoTypeStagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["starting","completed","in_progress"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPlanStepInfoTypeStagePropEnum = append(clusterPlanStepInfoTypeStagePropEnum, v)
	}
}

const (

	// ClusterPlanStepInfoStageStarting captures enum value "starting"
	ClusterPlanStepInfoStageStarting string = "starting"

	// ClusterPlanStepInfoStageCompleted captures enum value "completed"
	ClusterPlanStepInfoStageCompleted string = "completed"

	// ClusterPlanStepInfoStageInProgress captures enum value "in_progress"
	ClusterPlanStepInfoStageInProgress string = "in_progress"
)

// prop value enum
func (m *ClusterPlanStepInfo) validateStageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPlanStepInfoTypeStagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPlanStepInfo) validateStage(formats strfmt.Registry) error {

	if err := validate.Required("stage", "body", m.Stage); err != nil {
		return err
	}

	// value enum
	if err := m.validateStageEnum("stage", "body", *m.Stage); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPlanStepInfo) validateStarted(formats strfmt.Registry) error {

	if err := validate.Required("started", "body", m.Started); err != nil {
		return err
	}

	if err := validate.FormatOf("started", "body", "date-time", m.Started.String(), formats); err != nil {
		return err
	}

	return nil
}

var clusterPlanStepInfoTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["success","warning","error","pending"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPlanStepInfoTypeStatusPropEnum = append(clusterPlanStepInfoTypeStatusPropEnum, v)
	}
}

const (

	// ClusterPlanStepInfoStatusSuccess captures enum value "success"
	ClusterPlanStepInfoStatusSuccess string = "success"

	// ClusterPlanStepInfoStatusWarning captures enum value "warning"
	ClusterPlanStepInfoStatusWarning string = "warning"

	// ClusterPlanStepInfoStatusError captures enum value "error"
	ClusterPlanStepInfoStatusError string = "error"

	// ClusterPlanStepInfoStatusPending captures enum value "pending"
	ClusterPlanStepInfoStatusPending string = "pending"
)

// prop value enum
func (m *ClusterPlanStepInfo) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPlanStepInfoTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPlanStepInfo) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPlanStepInfo) validateStepID(formats strfmt.Registry) error {

	if err := validate.Required("step_id", "body", m.StepID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster plan step info based on the context it is used
func (m *ClusterPlanStepInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInfoLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPlanStepInfo) contextValidateInfoLog(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InfoLog); i++ {

		if m.InfoLog[i] != nil {
			if err := m.InfoLog[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("info_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPlanStepInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPlanStepInfo) UnmarshalBinary(b []byte) error {
	var res ClusterPlanStepInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
