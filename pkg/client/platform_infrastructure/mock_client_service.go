// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package platform_infrastructure

import (
	runtime "github.com/go-openapi/runtime"
	mock "github.com/stretchr/testify/mock"
)

// MockClientService is an autogenerated mock type for the ClientService type
type MockClientService struct {
	mock.Mock
}

// AddBlueprinterBlessing provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) AddBlueprinterBlessing(params *AddBlueprinterBlessingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddBlueprinterBlessingOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *AddBlueprinterBlessingOK
	if rf, ok := ret.Get(0).(func(*AddBlueprinterBlessingParams, runtime.ClientAuthInfoWriter, ...ClientOption) *AddBlueprinterBlessingOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AddBlueprinterBlessingOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*AddBlueprinterBlessingParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBlueprinterRole provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) CreateBlueprinterRole(params *CreateBlueprinterRoleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateBlueprinterRoleCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *CreateBlueprinterRoleCreated
	if rf, ok := ret.Get(0).(func(*CreateBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) *CreateBlueprinterRoleCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CreateBlueprinterRoleCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*CreateBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConfigStoreOption provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) CreateConfigStoreOption(params *CreateConfigStoreOptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateConfigStoreOptionCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *CreateConfigStoreOptionCreated
	if rf, ok := ret.Get(0).(func(*CreateConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) *CreateConfigStoreOptionCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CreateConfigStoreOptionCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*CreateConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProxiesFilteredGroup provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) CreateProxiesFilteredGroup(params *CreateProxiesFilteredGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateProxiesFilteredGroupOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *CreateProxiesFilteredGroupOK
	if rf, ok := ret.Get(0).(func(*CreateProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) *CreateProxiesFilteredGroupOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CreateProxiesFilteredGroupOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*CreateProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAdminconsoleLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteAdminconsoleLoggingSettings(params *DeleteAdminconsoleLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAdminconsoleLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteAdminconsoleLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*DeleteAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteAdminconsoleLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteAdminconsoleLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllocator provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteAllocator(params *DeleteAllocatorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAllocatorOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteAllocatorOK
	if rf, ok := ret.Get(0).(func(*DeleteAllocatorParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteAllocatorOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteAllocatorOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteAllocatorParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllocatorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteAllocatorLoggingSettings(params *DeleteAllocatorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAllocatorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteAllocatorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*DeleteAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteAllocatorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteAllocatorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllocatorMetadataItem provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteAllocatorMetadataItem(params *DeleteAllocatorMetadataItemParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAllocatorMetadataItemOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteAllocatorMetadataItemOK
	if rf, ok := ret.Get(0).(func(*DeleteAllocatorMetadataItemParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteAllocatorMetadataItemOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteAllocatorMetadataItemOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteAllocatorMetadataItemParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBlueprinterRole provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteBlueprinterRole(params *DeleteBlueprinterRoleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteBlueprinterRoleOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteBlueprinterRoleOK
	if rf, ok := ret.Get(0).(func(*DeleteBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteBlueprinterRoleOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteBlueprinterRoleOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConfigStoreOption provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteConfigStoreOption(params *DeleteConfigStoreOptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteConfigStoreOptionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteConfigStoreOptionOK
	if rf, ok := ret.Get(0).(func(*DeleteConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteConfigStoreOptionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteConfigStoreOptionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConstructorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteConstructorLoggingSettings(params *DeleteConstructorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteConstructorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteConstructorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*DeleteConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteConstructorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteConstructorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLicense provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteLicense(params *DeleteLicenseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLicenseOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteLicenseOK
	if rf, ok := ret.Get(0).(func(*DeleteLicenseParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteLicenseOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteLicenseOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteLicenseParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProxiesFilteredGroup provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteProxiesFilteredGroup(params *DeleteProxiesFilteredGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteProxiesFilteredGroupOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteProxiesFilteredGroupOK
	if rf, ok := ret.Get(0).(func(*DeleteProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteProxiesFilteredGroupOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteProxiesFilteredGroupOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRunner provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteRunner(params *DeleteRunnerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunnerOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteRunnerOK
	if rf, ok := ret.Get(0).(func(*DeleteRunnerParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteRunnerOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteRunnerOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteRunnerParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRunnerLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) DeleteRunnerLoggingSettings(params *DeleteRunnerLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunnerLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *DeleteRunnerLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*DeleteRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *DeleteRunnerLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DeleteRunnerLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*DeleteRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAPIBaseURL provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAPIBaseURL(params *GetAPIBaseURLParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAPIBaseURLOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAPIBaseURLOK
	if rf, ok := ret.Get(0).(func(*GetAPIBaseURLParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAPIBaseURLOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAPIBaseURLOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAPIBaseURLParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdminconsoleLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAdminconsoleLoggingSettings(params *GetAdminconsoleLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAdminconsoleLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAdminconsoleLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*GetAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAdminconsoleLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAdminconsoleLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdminconsoles provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAdminconsoles(params *GetAdminconsolesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAdminconsolesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAdminconsolesOK
	if rf, ok := ret.Get(0).(func(*GetAdminconsolesParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAdminconsolesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAdminconsolesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAdminconsolesParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllocator provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAllocator(params *GetAllocatorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAllocatorOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAllocatorOK
	if rf, ok := ret.Get(0).(func(*GetAllocatorParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAllocatorOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAllocatorOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAllocatorParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllocatorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAllocatorLoggingSettings(params *GetAllocatorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAllocatorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAllocatorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*GetAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAllocatorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAllocatorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllocatorMetadata provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAllocatorMetadata(params *GetAllocatorMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAllocatorMetadataOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAllocatorMetadataOK
	if rf, ok := ret.Get(0).(func(*GetAllocatorMetadataParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAllocatorMetadataOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAllocatorMetadataOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAllocatorMetadataParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllocatorSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAllocatorSettings(params *GetAllocatorSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAllocatorSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAllocatorSettingsOK
	if rf, ok := ret.Get(0).(func(*GetAllocatorSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAllocatorSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAllocatorSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAllocatorSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllocators provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetAllocators(params *GetAllocatorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAllocatorsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetAllocatorsOK
	if rf, ok := ret.Get(0).(func(*GetAllocatorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetAllocatorsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetAllocatorsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetAllocatorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlueprinterRole provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetBlueprinterRole(params *GetBlueprinterRoleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBlueprinterRoleOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetBlueprinterRoleOK
	if rf, ok := ret.Get(0).(func(*GetBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetBlueprinterRoleOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetBlueprinterRoleOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigStoreOption provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetConfigStoreOption(params *GetConfigStoreOptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConfigStoreOptionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetConfigStoreOptionOK
	if rf, ok := ret.Get(0).(func(*GetConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetConfigStoreOptionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetConfigStoreOptionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConstructor provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetConstructor(params *GetConstructorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConstructorOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetConstructorOK
	if rf, ok := ret.Get(0).(func(*GetConstructorParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetConstructorOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetConstructorOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetConstructorParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConstructorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetConstructorLoggingSettings(params *GetConstructorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConstructorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetConstructorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*GetConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetConstructorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetConstructorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConstructors provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetConstructors(params *GetConstructorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConstructorsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetConstructorsOK
	if rf, ok := ret.Get(0).(func(*GetConstructorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetConstructorsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetConstructorsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetConstructorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLicense provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetLicense(params *GetLicenseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLicenseOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetLicenseOK
	if rf, ok := ret.Get(0).(func(*GetLicenseParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetLicenseOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetLicenseOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetLicenseParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProxies provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetProxies(params *GetProxiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxiesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetProxiesOK
	if rf, ok := ret.Get(0).(func(*GetProxiesParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetProxiesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetProxiesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetProxiesParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProxiesFilteredGroup provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetProxiesFilteredGroup(params *GetProxiesFilteredGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxiesFilteredGroupOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetProxiesFilteredGroupOK
	if rf, ok := ret.Get(0).(func(*GetProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetProxiesFilteredGroupOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetProxiesFilteredGroupOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProxiesFilteredGroupHealth provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetProxiesFilteredGroupHealth(params *GetProxiesFilteredGroupHealthParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxiesFilteredGroupHealthOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetProxiesFilteredGroupHealthOK
	if rf, ok := ret.Get(0).(func(*GetProxiesFilteredGroupHealthParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetProxiesFilteredGroupHealthOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetProxiesFilteredGroupHealthOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetProxiesFilteredGroupHealthParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProxiesHealth provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetProxiesHealth(params *GetProxiesHealthParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxiesHealthOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetProxiesHealthOK
	if rf, ok := ret.Get(0).(func(*GetProxiesHealthParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetProxiesHealthOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetProxiesHealthOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetProxiesHealthParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProxiesSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetProxiesSettings(params *GetProxiesSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxiesSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetProxiesSettingsOK
	if rf, ok := ret.Get(0).(func(*GetProxiesSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetProxiesSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetProxiesSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetProxiesSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProxy provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetProxy(params *GetProxyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetProxyOK
	if rf, ok := ret.Get(0).(func(*GetProxyParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetProxyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetProxyOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetProxyParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunner provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetRunner(params *GetRunnerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunnerOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetRunnerOK
	if rf, ok := ret.Get(0).(func(*GetRunnerParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetRunnerOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetRunnerOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetRunnerParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunnerLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetRunnerLoggingSettings(params *GetRunnerLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunnerLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetRunnerLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*GetRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetRunnerLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetRunnerLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunners provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) GetRunners(params *GetRunnersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunnersOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *GetRunnersOK
	if rf, ok := ret.Get(0).(func(*GetRunnersParams, runtime.ClientAuthInfoWriter, ...ClientOption) *GetRunnersOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetRunnersOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*GetRunnersParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBlueprinterRoles provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ListBlueprinterRoles(params *ListBlueprinterRolesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBlueprinterRolesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ListBlueprinterRolesOK
	if rf, ok := ret.Get(0).(func(*ListBlueprinterRolesParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ListBlueprinterRolesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ListBlueprinterRolesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ListBlueprinterRolesParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListConfigStoreOption provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ListConfigStoreOption(params *ListConfigStoreOptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConfigStoreOptionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ListConfigStoreOptionOK
	if rf, ok := ret.Get(0).(func(*ListConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ListConfigStoreOptionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ListConfigStoreOptionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ListConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveClusters provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) MoveClusters(params *MoveClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MoveClustersAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *MoveClustersAccepted
	if rf, ok := ret.Get(0).(func(*MoveClustersParams, runtime.ClientAuthInfoWriter, ...ClientOption) *MoveClustersAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MoveClustersAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*MoveClustersParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveClustersByType provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) MoveClustersByType(params *MoveClustersByTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MoveClustersByTypeAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *MoveClustersByTypeAccepted
	if rf, ok := ret.Get(0).(func(*MoveClustersByTypeParams, runtime.ClientAuthInfoWriter, ...ClientOption) *MoveClustersByTypeAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MoveClustersByTypeAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*MoveClustersByTypeParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutConfigStoreOption provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) PutConfigStoreOption(params *PutConfigStoreOptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PutConfigStoreOptionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *PutConfigStoreOptionOK
	if rf, ok := ret.Get(0).(func(*PutConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) *PutConfigStoreOptionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PutConfigStoreOptionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*PutConfigStoreOptionParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncAllocator provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ResyncAllocator(params *ResyncAllocatorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResyncAllocatorOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ResyncAllocatorOK
	if rf, ok := ret.Get(0).(func(*ResyncAllocatorParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ResyncAllocatorOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResyncAllocatorOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ResyncAllocatorParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncAllocators provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ResyncAllocators(params *ResyncAllocatorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResyncAllocatorsAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ResyncAllocatorsAccepted
	if rf, ok := ret.Get(0).(func(*ResyncAllocatorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ResyncAllocatorsAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResyncAllocatorsAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ResyncAllocatorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncConstructor provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ResyncConstructor(params *ResyncConstructorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResyncConstructorOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ResyncConstructorOK
	if rf, ok := ret.Get(0).(func(*ResyncConstructorParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ResyncConstructorOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResyncConstructorOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ResyncConstructorParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncConstructors provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ResyncConstructors(params *ResyncConstructorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResyncConstructorsAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ResyncConstructorsAccepted
	if rf, ok := ret.Get(0).(func(*ResyncConstructorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ResyncConstructorsAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResyncConstructorsAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ResyncConstructorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncRunner provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ResyncRunner(params *ResyncRunnerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResyncRunnerOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ResyncRunnerOK
	if rf, ok := ret.Get(0).(func(*ResyncRunnerParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ResyncRunnerOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResyncRunnerOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ResyncRunnerParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncRunners provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) ResyncRunners(params *ResyncRunnersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResyncRunnersAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ResyncRunnersAccepted
	if rf, ok := ret.Get(0).(func(*ResyncRunnersParams, runtime.ClientAuthInfoWriter, ...ClientOption) *ResyncRunnersAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResyncRunnersAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*ResyncRunnersParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchAllocators provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SearchAllocators(params *SearchAllocatorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SearchAllocatorsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SearchAllocatorsOK
	if rf, ok := ret.Get(0).(func(*SearchAllocatorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SearchAllocatorsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SearchAllocatorsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SearchAllocatorsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchRunners provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SearchRunners(params *SearchRunnersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SearchRunnersOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SearchRunnersOK
	if rf, ok := ret.Get(0).(func(*SearchRunnersParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SearchRunnersOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SearchRunnersOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SearchRunnersParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAPIBaseURL provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetAPIBaseURL(params *SetAPIBaseURLParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetAPIBaseURLOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetAPIBaseURLOK
	if rf, ok := ret.Get(0).(func(*SetAPIBaseURLParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetAPIBaseURLOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetAPIBaseURLOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetAPIBaseURLParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAdminconsoleLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetAdminconsoleLoggingSettings(params *SetAdminconsoleLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetAdminconsoleLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetAdminconsoleLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*SetAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetAdminconsoleLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetAdminconsoleLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAllocatorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetAllocatorLoggingSettings(params *SetAllocatorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetAllocatorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetAllocatorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*SetAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetAllocatorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetAllocatorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAllocatorMetadata provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetAllocatorMetadata(params *SetAllocatorMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetAllocatorMetadataOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetAllocatorMetadataOK
	if rf, ok := ret.Get(0).(func(*SetAllocatorMetadataParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetAllocatorMetadataOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetAllocatorMetadataOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetAllocatorMetadataParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAllocatorMetadataItem provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetAllocatorMetadataItem(params *SetAllocatorMetadataItemParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetAllocatorMetadataItemOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetAllocatorMetadataItemOK
	if rf, ok := ret.Get(0).(func(*SetAllocatorMetadataItemParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetAllocatorMetadataItemOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetAllocatorMetadataItemOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetAllocatorMetadataItemParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAllocatorSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetAllocatorSettings(params *SetAllocatorSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetAllocatorSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetAllocatorSettingsOK
	if rf, ok := ret.Get(0).(func(*SetAllocatorSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetAllocatorSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetAllocatorSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetAllocatorSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetBlueprinterBlessings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetBlueprinterBlessings(params *SetBlueprinterBlessingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetBlueprinterBlessingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetBlueprinterBlessingsOK
	if rf, ok := ret.Get(0).(func(*SetBlueprinterBlessingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetBlueprinterBlessingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetBlueprinterBlessingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetBlueprinterBlessingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetConstructorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetConstructorLoggingSettings(params *SetConstructorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetConstructorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetConstructorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*SetConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetConstructorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetConstructorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLicense provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetLicense(params *SetLicenseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetLicenseOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetLicenseOK
	if rf, ok := ret.Get(0).(func(*SetLicenseParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetLicenseOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetLicenseOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetLicenseParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetProxiesSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetProxiesSettings(params *SetProxiesSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetProxiesSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetProxiesSettingsOK
	if rf, ok := ret.Get(0).(func(*SetProxiesSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetProxiesSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetProxiesSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetProxiesSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRunnerLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetRunnerLoggingSettings(params *SetRunnerLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetRunnerLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetRunnerLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*SetRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetRunnerLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetRunnerLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRunnerRoles provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) SetRunnerRoles(params *SetRunnerRolesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetRunnerRolesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *SetRunnerRolesOK
	if rf, ok := ret.Get(0).(func(*SetRunnerRolesParams, runtime.ClientAuthInfoWriter, ...ClientOption) *SetRunnerRolesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SetRunnerRolesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*SetRunnerRolesParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *MockClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// StartAllocatorMaintenanceMode provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) StartAllocatorMaintenanceMode(params *StartAllocatorMaintenanceModeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartAllocatorMaintenanceModeAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *StartAllocatorMaintenanceModeAccepted
	if rf, ok := ret.Get(0).(func(*StartAllocatorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) *StartAllocatorMaintenanceModeAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StartAllocatorMaintenanceModeAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*StartAllocatorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartConstructorMaintenanceMode provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) StartConstructorMaintenanceMode(params *StartConstructorMaintenanceModeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartConstructorMaintenanceModeAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *StartConstructorMaintenanceModeAccepted
	if rf, ok := ret.Get(0).(func(*StartConstructorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) *StartConstructorMaintenanceModeAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StartConstructorMaintenanceModeAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*StartConstructorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopAllocatorMaintenanceMode provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) StopAllocatorMaintenanceMode(params *StopAllocatorMaintenanceModeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopAllocatorMaintenanceModeAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *StopAllocatorMaintenanceModeAccepted
	if rf, ok := ret.Get(0).(func(*StopAllocatorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) *StopAllocatorMaintenanceModeAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StopAllocatorMaintenanceModeAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*StopAllocatorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopConstructorMaintenanceMode provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) StopConstructorMaintenanceMode(params *StopConstructorMaintenanceModeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopConstructorMaintenanceModeAccepted, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *StopConstructorMaintenanceModeAccepted
	if rf, ok := ret.Get(0).(func(*StopConstructorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) *StopConstructorMaintenanceModeAccepted); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StopConstructorMaintenanceModeAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*StopConstructorMaintenanceModeParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAdminconsoleLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateAdminconsoleLoggingSettings(params *UpdateAdminconsoleLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAdminconsoleLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateAdminconsoleLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*UpdateAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateAdminconsoleLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateAdminconsoleLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateAdminconsoleLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAllocatorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateAllocatorLoggingSettings(params *UpdateAllocatorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAllocatorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateAllocatorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*UpdateAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateAllocatorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateAllocatorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateAllocatorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAllocatorSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateAllocatorSettings(params *UpdateAllocatorSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAllocatorSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateAllocatorSettingsOK
	if rf, ok := ret.Get(0).(func(*UpdateAllocatorSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateAllocatorSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateAllocatorSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateAllocatorSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBlueprinterRole provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateBlueprinterRole(params *UpdateBlueprinterRoleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateBlueprinterRoleOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateBlueprinterRoleOK
	if rf, ok := ret.Get(0).(func(*UpdateBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateBlueprinterRoleOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateBlueprinterRoleOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateBlueprinterRoleParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConstructorLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateConstructorLoggingSettings(params *UpdateConstructorLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConstructorLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateConstructorLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*UpdateConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateConstructorLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateConstructorLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateConstructorLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProxiesFilteredGroup provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateProxiesFilteredGroup(params *UpdateProxiesFilteredGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProxiesFilteredGroupOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateProxiesFilteredGroupOK
	if rf, ok := ret.Get(0).(func(*UpdateProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateProxiesFilteredGroupOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateProxiesFilteredGroupOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateProxiesFilteredGroupParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProxiesSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateProxiesSettings(params *UpdateProxiesSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProxiesSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateProxiesSettingsOK
	if rf, ok := ret.Get(0).(func(*UpdateProxiesSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateProxiesSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateProxiesSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateProxiesSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRunnerLoggingSettings provides a mock function with given fields: params, authInfo, opts
func (_m *MockClientService) UpdateRunnerLoggingSettings(params *UpdateRunnerLoggingSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRunnerLoggingSettingsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *UpdateRunnerLoggingSettingsOK
	if rf, ok := ret.Get(0).(func(*UpdateRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) *UpdateRunnerLoggingSettingsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UpdateRunnerLoggingSettingsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*UpdateRunnerLoggingSettingsParams, runtime.ClientAuthInfoWriter, ...ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
